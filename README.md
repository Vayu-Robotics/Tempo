# Tempo
The Tempo Unreal Engine project and plugins
## Prerequisites
You will need the following:
- `jq`
- `curl`
- A `~/.netrc` file with a valid GitHub Personal Access Token for the TempoThirdParty repo in this format:
```
machine api.github.com
login user # Can be anything. Not used, but must be present.
password <your_token_here>
```
## Getting Started
Run `Setup.sh` (from the Tempo root) once to:
- Install the Tempo UnrealBuildTool toolchain
- Install third party dependencies
- Add git hooks to keep both of the above in sync automatically
## Scripting
Tempo supports scripting via [Protobuf](https://protobuf.dev/) and [gRPC](https://grpc.io/).
Any module can define messages and services to allow external clients to control the editor or game.
To do so, a module must:
- Derive its module rules from `TempoModuleRules` (instead of `ModuleRules`)
- Add `TempoScripting` as a dependency

[!IMPORTANT]  
You must **not** add `gRPC` as a direct dependency of your module. `gRPC` is a public dependency of `TempoScripting`, and you must receive the dependency through it.

### Defining Messages and Services
You can add proto files anywhere in your module's Public or Private folder and the corresponding C++ and Python code
will be automatically generated in a pre-build step. Tempo enforces some conventions on the proto files you write, which enable
composable proto files. Proto files may import others, with appropriate visibility as defined by the module
dependency graph. Importing is allowed if:
  - The imported proto file is in the same module (Public or Private folder) as the importing proto file **or**
  - The module with the importing proto file depends on the module with the imported proto file **and**
  - The module with the imported proto file defines it in it's Public folder

Composability necessitates file name and message/service name de-conflicting. All the following cases are allowed:
  - Two modules may define a proto file with the same name and relative path (for example, "/Utils.proto")
  - One module may define two proto files with the same name and different relative path (for example,
    "/Utils.proto" and also "/Transforms/Utils.proto")
  - One module may define two proto files with services or messages that have the same names

[!NOTE]  
You may **not** add `package` statements to your proto files. Tempo will automatically add a `package` to every proto file during the build based on
the file's module and relative path. This is key to enabling the message and service name de-conflicting above. 

When importing/including proto files or protobuf-generated code in other proto files, C++, or Python code your
imports/#includes must follow the convention
```
ModuleName/RelativePath/FileName.<proto/pb.h/_pb2.py>
```
When you refer to proto messages or services from anywhere outside of the proto file where they are defined you must refer to them
by their fully-qualified name, according to the autogenerated `package`. So that means:

In proto files:
```
ModuleName.RelativePath.FileName.MessageName
```
In C++:
```
ModuleName::RelativePath::FileName::MessageName
```
Note that there are no namespaces in Python (proto package names have no effect on the generated Python code),
but de-conflicting can still be achieved with appropriate import statements.

### Registering Services
The `TempoScripting` module hosts two scripting servers. One (the "Engine Scripting Server") is always active, including before play in the Editor, and the other
(the "World Scripting Server") is only active during play in a game world. Based on the functionality you're trying to expose, you should register your service
with either one. The Engine and World servers are owned by the `TempoScriptingEngineSubsystem` and `TempoScriptingWorldSubsystem`, respectively. You can register
your service like this:

```
#include "TempoScriptingWorldSubsystem";

#include "MyModule/RelativePath/MyProtoFile.grpc.pb.h";

using MyService = MyModule::RelativePath::MyProtoFile::MyService::AsyncService;
using MyRequest = MyModule::RelativePath::MyProtoFile::MyRequest;
using MyResponse = MyModule::RelativePath::MyProtoFile::MyResponse;

void AMyScriptableActor::BeginPlay()
{
    Super::BeginPlay();
    
    check(GetWorld());
    GetWorld()->GetSubsystem<UTempoScriptingWorldSubsystem>()->GetScriptingServer()->RegisterService<MyService>(
        TRequestHandler<MyService, MyRequest, MyResponse>(&AMyScriptableActor::RequestMyRPC).BindUObject(this, &AMyScriptableActor::HandleMyRequest)
    );
}

grpc::Status AMyScriptableActor::HandleMyRequest(const MyRequest& Request, MyResponse& Response)
{
    // Handle the request, produce the response.
    
    return grpc::Status(); // Return a status indicating if the request was handled successfully.
}
```
You should include a TRequestHandler for every RPC in your service. You may not bind multiple handlers to one RPC.
